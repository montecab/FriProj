using UnityEngine;
using System.Collections.Generic;
using WW.SimpleJSON;
using System;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;

namespace Turing {
  public class trProgram : trBase {

    // xl8_info: This is the template for program name '{noun} and {noun}'. Ex: Tiger and Unicorn
    private static readonly string PROGRAM_NAME_FORMAT = "@!@{0} and {1}@!@";

    public static int CurrentVersion = 3;

    public bool IsFutureVersion{
      get{
        return Version > CurrentVersion;
      }
    }
    public  string             UserFacingName;
    public  int                Version;
    public  Dictionary<string, trState     > UUIDToStateTable      = new Dictionary<string, trState     >();
    public  Dictionary<string, trTransition> UUIDToTransitionTable = new Dictionary<string,trTransition>();
    public  Dictionary<string, trBehavior  > UUIDToBehaviorTable   = new Dictionary<string, trBehavior>();
    public  long RecentLoadedTime = 0;

    public  bool             ThumbnailDirty = true; 
    public  string           ThumbnailPath{
      get{
        return Application.persistentDataPath + "/tn_" + UUID + ".png";
      }
    }

    public bool              IsThumbnailExist{
      get{
        return File.Exists(ThumbnailPath);
      }
    }
    public  trState          StateStart   = null;
    private trState          stateCurrent = null;
    private trState          stateOmni    = null;
    public  trMoodType       MoodCurrent  = trMood.DefaultMood;
    public  piRobotType      RobotType    = piRobotType.DASH;
    public  Vector2          ScrollPosition = Vector2.zero;
    public  string           ParentToken = "";

    public delegate void TransitionActivatedDelegate(trTransition transition);
    public TransitionActivatedDelegate OnTransitionActivated;

    public static System.Random RandomGenerator = new System.Random();
    private static List<string> fileNameWord = null;
    public static List<string> FileNameWord{
      get{
        if (fileNameWord == null){
          fileNameWord = new List<string>();
          // DO NOT EDIT THE CODE BELOW! IT IS GENERATED BY THIS SPREADSHEET:
          // https://docs.google.com/spreadsheets/d/1gccOs1yIe2lUmDRtA9-zyCjHAi_aCFkYPwXHsqK9djM/edit#gid=1244430451
          // to make changes, edit the spreadsheet, then manually copy-and-paste the code generated in the spreadsheet.
          fileNameWord.Add("Unicorn");
          fileNameWord.Add("Penguin");
          fileNameWord.Add("Cloud");
          fileNameWord.Add("Rainbow");
          fileNameWord.Add("House");
          fileNameWord.Add("Castle");
          fileNameWord.Add("Pony");
          fileNameWord.Add("Whale");
          fileNameWord.Add("Panda");
          fileNameWord.Add("Drum");
          fileNameWord.Add("Lollipop");
          fileNameWord.Add("Snow");
          fileNameWord.Add("Dragon");
          fileNameWord.Add("Cat");
          fileNameWord.Add("Dog");
          fileNameWord.Add("Puppy");
          fileNameWord.Add("Monkey");
          fileNameWord.Add("Jungle");
          fileNameWord.Add("Cup");
          fileNameWord.Add("Shoes");
          fileNameWord.Add("Boat");
          fileNameWord.Add("Train");
          fileNameWord.Add("Shark");
          fileNameWord.Add("Grass");
          fileNameWord.Add("Tree");
          fileNameWord.Add("Kangaroo");
          fileNameWord.Add("Koala");
          fileNameWord.Add("Alligator");
          fileNameWord.Add("Eagle");
          fileNameWord.Add("Bird");
          fileNameWord.Add("Butterfly");
          fileNameWord.Add("Chair");
          fileNameWord.Add("Monster");
          fileNameWord.Add("Robot");
          fileNameWord.Add("Sloth");
          fileNameWord.Add("Balloon");
          fileNameWord.Add("Fruit");
          fileNameWord.Add("Flower");
          fileNameWord.Add("Kiwi");
          fileNameWord.Add("Lion");
          fileNameWord.Add("Zebra");
          fileNameWord.Add("Corn");
          fileNameWord.Add("Pig");
          fileNameWord.Add("Mouse");
          fileNameWord.Add("Fish");
          fileNameWord.Add("Dash");
          fileNameWord.Add("Dot");
          fileNameWord.Add("Path");
          fileNameWord.Add("Xylophone");
          fileNameWord.Add("Bunny");
        }
        return fileNameWord;
      }
    }

    public bool IsInitialized {
      get {
        return (this.UUIDToStateTable.Count > 0);
      }
    }
    public trState StateCurrent {
      get {
        return stateCurrent;
      }
    }

    public trState StateOmni {
      set {
        if (stateOmni != null) {
          stateOmni.IsOmniState = false;
        }
        
        stateOmni = value;
        
        if (stateOmni != null) {
          stateOmni.IsOmniState = true;
        }
      }
      get {
        return stateOmni;
      }
    }

    public trProgram DeepCopy(){
      trProgram ret =  trFactory.FromJson<trProgram>(this.ToJson());
      ret.UUID = wwUID.getUID();
      return ret;
    }

    private void initToBlank(piRobotType robotType) {
      Version = trProgram.CurrentVersion;
      UUIDToTransitionTable.Clear();
      UUIDToStateTable.Clear();
      UUIDToBehaviorTable.Clear();
      UserFacingName = newFileNameLocalized(robotType);
      RobotType = robotType;      
      trState state = new trState();
      state.Behavior = trBehavior.GetDefaultBehavior(trBehaviorType.START_STATE);
      AddState(state);
      StateStart = state;
      RecentLoadedTime = System.DateTime.Now.ToFileTimeUtc();      
    }

    public static trProgram NewProgram(piRobotType robotType) {
      trProgram ret = new trProgram();
      ret.initToBlank(robotType);
      return ret;
    }
    
    public static string potentialFilenameLocalized(){
      string potentialName = wwLoca.Format(PROGRAM_NAME_FORMAT, 
        wwLoca.Format(FileNameWord[RandomGenerator.Next(0, FileNameWord.Count)]),
        wwLoca.Format(FileNameWord[RandomGenerator.Next(0, FileNameWord.Count)]));
      return potentialName;
    }

    private static string newFileNameLocalized(piRobotType robotType){
      string name = null;
      bool validName = false;
      for (int i = 0; (i < 100) && !validName; i++){
        name = potentialFilenameLocalized();
        bool foundDuplicate = false;
        foreach(trProgram program in trDataManager.Instance.AppSaveInfo.Programs){
          if ((program.RobotType == robotType) && name.Equals(program.UserFacingName)){
            foundDuplicate = true;
            WWLog.logDebug(name + " is a duplicate, trying again");
            break;
          }
        }
        validName = !foundDuplicate;
      }
      if (!validName){
        WWLog.logError("oh no!!!! we ran out of names to use, generating random names");
        name += DateTime.Now.Millisecond.ToString();
      }
      return name;
    }
    
    public static trProgram NewProgram(){
      return NewProgram(trDataManager.Instance.CurrentRobotTypeSelected);
    } 
    
    public void TouchRecentLoadedTime() {
      RecentLoadedTime = System.DateTime.Now.ToFileTimeUtc();
    }

    public bool IsStateAllowedToSetMood(trState state){
      return state != StateOmni;
    }

    public void AddTransition(trTransition trans){
      if(trans.StateSource.AddOutgoingTransition(trans)){
        UUIDToTransitionTable.Add(trans.UUID, trans);
      }
      else{
        WWLog.logError("Fail to add transition. Transition invalid");
      }
    }

    public void AddBehavior(trBehavior behavior){
      if(behavior == null){
        WWLog.logError("Trying to add null behavior");
        return;
      }

      if(UUIDToBehaviorTable.ContainsKey(behavior.UUID)){
        WWLog.logInfo("Adding existed behavior, ignore");
        return;
      }
      UUIDToBehaviorTable.Add(behavior.UUID, behavior);
    }

    public void RemoveBehavior(trBehavior behavior){
      if(behavior == null){
        WWLog.logError("Trying to remove null behavior");
        return;
      }

      if(!UUIDToBehaviorTable.ContainsKey(behavior.UUID)){
        WWLog.logInfo("Removing non-existed behavior, ignore");
        return;
      }
      UUIDToBehaviorTable.Remove(behavior.UUID);
    }

    public void setStateBehaviour(trState state, trBehavior behaviour){
      trBehavior oldStateBehaviour = state.Behavior;

      if(oldStateBehaviour != null){
        bool shouldRemoveOldBehaviour = true;
        foreach(var item in UUIDToStateTable.Values){
          if (item != state && item.Behavior.UUID == oldStateBehaviour.UUID){
            shouldRemoveOldBehaviour = false;
            break;
          }
        }

        if (shouldRemoveOldBehaviour && state.Behavior != null){
         RemoveBehavior(oldStateBehaviour);
        }
      }

      state.Behavior = behaviour;
      state.ResetBehaviorParameterValue();

      if(behaviour != null && behaviour.isAnimation()){
        state.BehaviorParameterValue = behaviour.Animation.id;
      }

      if (behaviour != null && !UUIDToBehaviorTable.ContainsKey(behaviour.UUID)){
        AddBehavior(behaviour);
      }
    }

    public virtual void AddState(trState state){
      if(state == null){
        WWLog.logError("State should not be null");
        return;
      }
      if(state.Behavior == null){
        WWLog.logError("State behavior should not be null");
        return;
      }

      if(!UUIDToBehaviorTable.ContainsKey(state.Behavior.UUID)){
        AddBehavior(state.Behavior);
        WWLog.logInfo("Adding new behavior to program");
      }

      UUIDToStateTable.Add(state.UUID, state);
    }

    public void RemoveState(trState state){

      if (state == StateCurrent) {
        SetState(StateStart, null);
      }
            
      if (!UUIDToStateTable.ContainsValue(state)) {
        WWLog.logError("attempting to remove unknown state: " + state.ToString());
        return;
      }
      UUIDToStateTable.Remove(state.UUID);

      if (state.IsOmniState) {
        if (this.stateOmni != state) {
          WWLog.logError("state machine is corrupt: state thinks it's omni but program doesn't. " + state.ToString());
        }
        this.StateOmni = null;
      }

      RemoveAllStateTransitions(state);

      setStateBehaviour(state, null);

    }

    public void RemoveAllStateTransitions(trState state){
      List<trTransition> transitionsToDelete = AllStateTransitions(state);
      
      foreach(var item in transitionsToDelete){
        RemoveTransition(item);
      }
    }

    public List<trTransition> AllStateTransitions(trState state){
      List<trTransition> result = new List<trTransition>();
      foreach(var item in UUIDToTransitionTable.Values){
        if (item.StateSource == state || item.StateTarget == state){
          result.Add(item);
        }
      }
      return result;
    }

    public void RemoveTransition(trTransition transition) {
      if (transition.StateSource == null) {
        WWLog.logError("transition with null source.");
      }
      else {
        if (!transition.StateSource.OutgoingTransitions.Remove(transition)){
          WWLog.logError("error in removing transition from StateSource");
        }
      }

      if (!UUIDToTransitionTable.Remove(transition.UUID)){
        WWLog.logError("error in removing transition from Program.Transitions");
      }
    }
    
    #region serialization
    protected override void IntoJson(JSONClass jsc) {
      Validate();

      JSONArray jsa;

      jsa = new JSONArray();
      foreach (trBehavior x in UUIDToBehaviorTable.Values) {
        if(x.Type == trBehaviorType.FUNCTION){
          jsa.Add(x.ToJson());
        }
      }
      jsc[TOKENS.FUNCTIONS] = jsa;

      jsa = new JSONArray();
      foreach (trBehavior x in UUIDToBehaviorTable.Values) {
        if(x.Type != trBehaviorType.FUNCTION){
          jsa.Add(x.ToJson());
        }
      }
      jsc[TOKENS.BEHAVIORS] = jsa;
      
      jsa = new JSONArray();
      foreach (trState x in UUIDToStateTable.Values) {
        jsa.Add(x.ToJson());
      }
      jsc[TOKENS.STATES] = jsa;
      
      jsa = new JSONArray();
      foreach (trTransition x in UUIDToTransitionTable.Values) {
        jsa.Add(x.ToJson());
      }
      jsc[TOKENS.TRANSITIONS] = jsa;

      if(StateStart!= null){
        jsc[TOKENS.STATE_START_ID] = StateStart.UUID;
      }

      if(StateOmni != null){
        jsc[TOKENS.STATE_OMNI_ID] = StateOmni.UUID;
      }

      jsc[TOKENS.PARENT_TOKEN] = ParentToken ; 
      jsc[TOKENS.USER_FACING_NAME] = sanitizeFilename(UserFacingName);
      jsc[TOKENS.VERSION].AsInt = Version;
      jsc[TOKENS.ROBOT_TYPE].AsInt = (int)RobotType;
      jsc[TOKENS.LOADED_TIME] = RecentLoadedTime.ToString();
      jsc[TOKENS.LAYOUT_POSITION        ] = trFactory.ToJson(ScrollPosition);
      base.IntoJson(jsc);
    }

    public void LoadFromProgramJson(string programData) {
      if (!string.IsNullOrEmpty(programData)) {
        try {
          JSONNode jsn = JSON.Parse(programData);
          this.OutOfJson(jsn.AsObject);
        }
        catch(System.Exception e) {
          emitValidationError("exception while parsing program json. clearing. error: " + e.ToString());
          dealWithCorruption();
        }
      }
      else {
        emitValidationError("null json string. clearing.");
        dealWithCorruption();
      }
    }

    private void dealWithCorruption() {
      // clearing the program. see discussion in TUR-2063.
      piRobotType rt = this.RobotType;
      if (rt == piRobotType.UNKNOWN) {
        rt = trDataManager.Instance.CurrentRobotTypeSelected;
      }
      string oldName    = this.UserFacingName;
      initToBlank(rt);
      if (!string.IsNullOrEmpty(oldName)) {
        this.UserFacingName = oldName;
      }
    }

    protected override void OutOfJson(JSONClass jsc) {
      base.OutOfJson(jsc);

      try {
      
        UUIDToBehaviorTable  .Clear();
        UUIDToStateTable     .Clear();
        UUIDToTransitionTable.Clear();

        UserFacingName = sanitizeFilename(jsc[TOKENS.USER_FACING_NAME]);
        if(jsc[TOKENS.VERSION]== null){
          Version = 0;
        }else{
          Version = jsc[TOKENS.VERSION].AsInt;
        }

        if(Version > CurrentVersion){
          return;
        }

        if(jsc[TOKENS.PARENT_TOKEN] != null){
          ParentToken = jsc[TOKENS.PARENT_TOKEN];
        }

        // ORDER IS IMPORTANT HERE. first behaviors, then states, then transitions.

        //Call forget items because different programs could have different behaviors with the same id
        trFactory.ForgetItems();
        foreach(JSONClass jsc2 in jsc[TOKENS.FUNCTIONS].AsArray){
          trFunctionBehavior func = trFactory.FromJson<trFunctionBehavior>(jsc2);
          AddBehavior(func);
        }

        foreach(JSONClass jsc2 in jsc[TOKENS.BEHAVIORS  ].AsArray) {
          trBehavior behav = trFactory.FromJson<trBehavior>(jsc2);
          AddBehavior(behav);
        }
        foreach(JSONClass jsc2 in jsc[TOKENS.STATES     ].AsArray) {
          trState state = trFactory.FromJson<trState>(jsc2);
          UUIDToStateTable.Add(state.UUID, state);
        }
        foreach(JSONClass jsc2 in jsc[TOKENS.TRANSITIONS].AsArray) {
          trTransition trans = trFactory.FromJson<trTransition>(jsc2);
          UUIDToTransitionTable.Add(trans.UUID, trans);
        }

        if(jsc[TOKENS.STATE_START_ID] != null){
          StateStart = trFactory.GetItem<trState>(jsc[TOKENS.STATE_START_ID]);
          CorrectStartStateBehaviour();
        }

        if(jsc[TOKENS.STATE_OMNI_ID] != null){
          StateOmni = trFactory.GetItem<trState>(jsc[TOKENS.STATE_OMNI_ID]);
          CorrectOmniStateBehaviour();
        }

        if (jsc[TOKENS.ROBOT_TYPE] == null) {
          RobotType = piRobotType.DASH; // For exisiting programs which do not make this differentiation, We assume these programs are Dash
        } else {
          RobotType = (piRobotType)(jsc[TOKENS.ROBOT_TYPE].AsInt);
        }

        if (jsc[TOKENS.LOADED_TIME] != null){
          RecentLoadedTime = long.Parse(jsc[TOKENS.LOADED_TIME]);
        } else {
          RecentLoadedTime = 0;
        }

        if(jsc[TOKENS.LAYOUT_POSITION] != null){
          ScrollPosition = trFactory.FromJson(jsc[TOKENS.LAYOUT_POSITION].AsObject);
        }

        ProgramVersionFix();

        bool valid = Validate();
        if (!valid) {
          emitValidationError("program fails validation.");
          dealWithCorruption();
        }
      }
      catch(System.Exception e) {
        emitValidationError("exception while parsing program contents. clearing. error: " + e.ToString());
        dealWithCorruption();
      }

    }

    public void CenterStatesOnCanvas(){
      Vector2 averagePosition = Vector2.zero;

      foreach(trState state in UUIDToStateTable.Values){
        averagePosition += state.LayoutPosition;
      }

      averagePosition /= UUIDToStateTable.Count;

      foreach(trState state in UUIDToStateTable.Values){
        state.LayoutPosition -= averagePosition;
      }
    }

    public void ProgramVersionFix(){
      foreach(trState state in UUIDToStateTable.Values){
        if( !UUIDToBehaviorTable.ContainsKey(state.Behavior.UUID)){
          AddBehavior(state.Behavior);
        }
      }
      if(Version < CurrentVersion){
        if(Version < 1){
          trState startState = StateStart;
          
          trState newState = new trState();
          newState.Behavior = trBehavior.GetDefaultBehavior(trBehaviorType.DO_NOTHING);
          
          AddState(newState);
          
          trTransition transition = new trTransition();
          transition.StateSource = newState;
          transition.StateTarget = startState;
          transition.Trigger = new trTrigger(trTriggerType.TIME);
          transition.Trigger.ParameterValue = 0;
          UUIDToTransitionTable.Add(transition.UUID, transition);
          
          newState.OutgoingTransitions.Add(transition);
          StateStart = newState;
          
        }
        
        if(Version < 2){
          foreach(trState state in UUIDToStateTable.Values){
            if(state.Behavior.IsParameterized){
              state.BehaviorParameterValue = state.Behavior.Denomalize(state.BehaviorParameterValue);
            }
          }
        }
        
        Version = trProgram.CurrentVersion;
      }
      else if(Version > CurrentVersion){
        WWLog.logWarn("This is a program " + UserFacingName + " from the future. Download the latest version to view the program");
      }
    }
    #endregion serialization

    public void CorrectOmniStateBehaviour(){
      if (StateOmni != null && StateOmni.Behavior.Type != trBehaviorType.OMNI){
        WWLog.logWarn("correcting omni state behavior. previous: " + StateOmni.Behavior.ToString());
        setStateBehaviour(StateOmni, new trBehavior(trBehaviorType.OMNI));
      }
    }

    public void CorrectStartStateBehaviour(){
      if (StateStart != null && StateStart.Behavior.Type != trBehaviorType.START_STATE){
        WWLog.logWarn("correcting start state behavior. previous: " + StateStart.Behavior.ToString());
        setStateBehaviour(StateStart, new trBehavior(trBehaviorType.START_STATE));
      }
    }
    
    #region validation
    public virtual bool Validate(){

      var validationResult = true;
      foreach (trBehavior item in UUIDToBehaviorTable.Values){
        validationResult = validationResult && isBehaviourValid(item);
      }

      foreach(trState item in UUIDToStateTable.Values){
        validationResult = validationResult && isStateValid(item);
      }

      foreach(trTransition item in UUIDToTransitionTable.Values){
        validationResult = validationResult && isTransitionValid(item);
      }
      
      validationResult = validationResult && UUIDsAreUnique<trState     >(UUIDToStateTable     .Values);
      validationResult = validationResult && UUIDsAreUnique<trBehavior  >(UUIDToBehaviorTable  .Values);
      validationResult = validationResult && UUIDsAreUnique<trTransition>(UUIDToTransitionTable.Values);
      
      validationResult = validationResult && isStartStateValid();
      validationResult = validationResult && isOmniStateValid();
      
//      WWLog.logWarn("HEXDUMP OF PROGRAM:\n" + piStringUtil.byteArrayToString2(new trToFirmware().toFirmware(this)));

//      DumpAutoTransitionDescriptions();

      return validationResult;
    }

    private bool UUIDsAreUnique<T>(IEnumerable<T> collection) where T: trBase {
      bool ret = true;
      
      HashSet<string> uuids = new HashSet<string>();
      
      foreach(T trB in collection) {
        if (uuids.Contains(trB.UUID)) {
          emitValidationError("UUID collision, program: \"" + UserFacingName + "\" type: " + typeof(T).ToString() + "  uuid: " + trB.UUID);
          ret = false;
        }
        uuids.Add(trB.UUID);
      }
      
      return ret;
    }

    private bool isBehaviourValid(trBehavior behaviour){
      bool isUsed = false;
      
      // verify that this behavior is in fact used by the state machine.
      foreach (var item in UUIDToStateTable.Values){
        if (item.Behavior.UUID == behaviour.UUID){
          isUsed = true;
          break;
        }
      }
      if (!isUsed){
        emitValidationError(string.Format("(non-fatal) unused behaviour: {0}", behaviour));
      }

      return true;  // we're not considering this a fatal problem
    }

    private bool isStateValid(trState state){
      bool ret = true;
      
      bool behaviorKnown = UUIDToBehaviorTable.ContainsKey(state.Behavior.UUID);
      ret = ret && behaviorKnown;
      
      if (!behaviorKnown){
        emitValidationError(string.Format("unknown behaviour: {0}", state));
      }
      
      // verify that sounds are in their correct categories.
      if (state.Behavior.Type.IsSound()) {
        uint soundId = (uint)state.BehaviorParameterValue;
        // verify known sound
        trRobotSound trRS = trRobotSounds.Instance.GetSound(soundId, RobotType);
        if (trRS == null) {
          emitValidationError(string.Format("Unknown sound: {0} for robot: {1}. State = {2}",
              soundId, RobotType.ToString(), state.UUID));
        }
        else {
          if (trRS.category != state.Behavior.Type) {
            emitValidationError(string.Format("Sound in wrong category. Program: {0} Sound: {1} ID: {2} Wrong Category: {3} Right Category: {4}",
              UserFacingName, trRS.UserFacingNameUnlocalized, soundId, state.Behavior.Type.ToString(), trRS.category.ToString()));
          }
        }
      }

      // non-fatal, because of legacy challenges:
      return true;
    }

    private bool isTransitionValid(trTransition transition){
      bool ret = true;
      bool localResult = true;
      string errorType = "";
      
      localResult = (transition.StateSource != null) && (transition.StateTarget != null);
      if (!localResult){
        errorType = string.Format("bad transition state {0}", transition.StateSource == null ? "StateSource" : "StateTarget");
        emitValidationError(string.Format("{0}: {1}", errorType, transition));
        ret = false;
      }
      
      localResult = UUIDToStateTable.ContainsValue(transition.StateSource) && UUIDToStateTable.ContainsValue(transition.StateTarget);
      if (!localResult){
        errorType = string.Format("{0} is not accessablie", UUIDToStateTable.ContainsValue(transition.StateSource) == false ? "StateSource" : "StateTarget");
        emitValidationError(string.Format("{0}: {1}", errorType, transition));
        ret = false;
      }
      
      if (transition.StateSource != null){
        localResult = transition.StateSource.OutgoingTransitions.Contains(transition);
        if (!localResult){
          errorType = "StateSource doesn't have transition";
          emitValidationError(string.Format("{0}: {1}", errorType, transition));
          ret = false;
        }
      }
      
      localResult = transition.Trigger != null;
      if (!localResult){
        errorType = "Transition with null trigger";
        emitValidationError(string.Format("{0}: {1}:", errorType, transition));
        ret = false;
      }
      
      return ret;
    }

    private bool isStartStateValid(){
      bool ret = true;
      bool localResult = true;
      
      localResult = StateStart != null;
      if (!localResult){
        emitValidationError("program start state is null");
        ret = false;
      }
      
      localResult = UUIDToStateTable.ContainsValue(StateStart);
      if (!localResult){
        emitValidationError(string.Format("program start state is inaccessible: {0}", StateStart));
        ret = false;
      }
      return ret;
    }

    private bool isOmniStateValid(){
      bool ret = true;
      if (StateOmni != null){
        ret = UUIDToStateTable.ContainsValue(StateOmni);
      }
      if (!ret){
        emitValidationError(string.Format("program omni state is inaccessible: {0}", StateOmni));
      }
      return ret;
    }

    private void emitValidationError(string msg) {
      string s = "Error validating program. " + msg;
      WWLog.logError(s);
      new trTelemetryEvent(trTelemetryEventType.ERR_PROGRAM_VALIDATION, true)
        .add(trTelemetryParamType.DETAIL, s)
        .add(trTelemetryParamType.ID    , UUID)
        .emit();
    }

    #endregion validation
    
    public string ToString(piBotBase robot) {
      string ret = "";
      
      ret += TOKENS.STATE_START_ID.ToString() + ": " + StateStart.UserFacingName + "\n";
      ret += "\n";
      
      foreach (trState stt in UUIDToStateTable.Values) {
        bool active = ((stt == StateOmni) || (stt == StateCurrent));
        ret += stt.ToString(active, robot);
      }
      
      return ret;
    }
    
    public string AllTriggerStatus(piBotBase robot) {
      string ret = "";
      
      trTrigger trg = new trTrigger();
      foreach (trTriggerType enumCandidate in System.Enum.GetValues(typeof(trTriggerType))) {
        trg.Type = enumCandidate;
        string s = trg.Type.ToString().ToLower();
        if (trg.conditionMatches(robot, StateCurrent) == trTriggerConditionIsMet.YES) {
          s = s.ToUpper();
        }
        else if (trg.conditionMatches(robot, StateCurrent) == trTriggerConditionIsMet.UNKNOWN) {
          s = s + "?";
        }
        
        ret += s + " ";
      }
      
      return ret;
    }
    
    public List<trTrigger> GetAllTriggers() {
      List<trTrigger> ret = new List<trTrigger>();
      foreach(trTransition trn in UUIDToTransitionTable.Values) {
        if (!ret.Contains(trn.Trigger)) {
          ret.Add(trn.Trigger);
        }
      }
      
      return ret;
    }
    
    public void Reset(piBotBase robot, bool isSetCurStateNull = false) {

      if (robot != null) {
        ((piBotBo)robot).cmd_bodyMotionStop();
      }
      
      foreach (trState stt in UUIDToStateTable.Values) {
        stt.SetActive(false, robot, ref MoodCurrent);
      }

      // the start       
      if (StateStart != null) {
        foreach (trTransition trTrn in StateStart.OutgoingTransitions) {
          if (trTrn.Trigger != null) {
            trTrn.Trigger.Primed = true;
          }
        }
      }
      
      // the omni
      if (StateOmni != null) {
        StateOmni.Tare(robot);
        foreach (trTransition trTrn in StateOmni.OutgoingTransitions) {
          if (trTrn.Trigger != null) {
            trTrn.Trigger.Primed = true;
          }
        }
      }
      
      NormalizeTransitionOrdering();

      if(isSetCurStateNull){
        SetState(null, robot);
      }
      else{
        SetState(StateStart, robot);
      }
     
    }
    
    public void SetState(trState state, piBotBase robot) {
      if (stateCurrent != null) {
        stateCurrent.SetActive(false, robot, ref MoodCurrent);
      }
      
      stateCurrent = state;
      
      if (stateCurrent != null) {
        stateCurrent.SetActive(true, robot, ref MoodCurrent);
      }
      
      if (stateOmni != null) {
        stateOmni.Behavior.startBehaving(robot);
      }
    }
    
    public void NormalizeTransitionOrdering() {
      foreach (trState trStt in UUIDToStateTable.Values) {
        trStt.NormalizeTransitionOrdering();
      }
    }
    
    // returns true iff state is changed.
    public virtual bool OnRobotState(piBotBase robot) {
      if(StateCurrent == null){
        return false;
      }
//      piBotBo bot = (piBotBo)robot;
//      WWLog.logWarn("incoming robot state: "
//                     + " " + bot.Beacon.dataLeft.ToString("0000")
//                     + " " + bot.Beacon.dataRight.ToString("0000")
//                     + " " + bot.DistanceSensorFrontLeft  .WindowedDistance.ToString("00")
//                     + " " + bot.DistanceSensorFrontCenter.WindowedDistance.ToString("00")
//                     + " " + bot.DistanceSensorFrontRight .WindowedDistance.ToString("00")
//                     );
      
      
      // this line is the core of the entire state-machine model:
      // ask the current state if it would like to transition based on the input.
      trTransition trn = StateCurrent.GetTransition(robot);
      
      // omni state gets a shot afterwards:
      if (StateOmni != null) {

        trTransition trnOmni = stateOmni.GetTransition(robot);
        bool omniWins = (trnOmni != null) && ((trn == null) || trnOmni.Trigger.Type.IsPossiblyTimeBased());

        if (omniWins) {
          trn = trnOmni;
        }

        if (omniWins) {
          // need to tare OMNI because down below SetState() only tares the target state.
          StateOmni.Tare(robot);
        }

        // we have an omni but the regular state-machine stole the show.  <--- this comment not quite true.
        StateOmni.ResetTriggers(robot);
      }
      
      if (trn != null) {
        SetState(trn.StateTarget, robot);
        if (trn.OnTransitionActivated != null){
          trn.OnTransitionActivated();
        }
        if (OnTransitionActivated != null){
          OnTransitionActivated(trn);
        }
      }
      
      if (StateCurrent != null) {
        StateCurrent.BehaveContinuous(robot);
      }
      
      // clear out the list of incoming events.
      robot.IncomingEvents.Clear();
      
      return (trn != null);
    }
    
    public static string sanitizeFilename(string s, bool allowTrailingSpace = false) {
      string ret = TMPro.TMP_TextUtilities.ReplaceUnsupportedCharacters(s);
      if (ret != s) {
        WWLog.logWarn("simplified filename from \"" + s + "\" to \"" + ret + "\".");
      }

      if (allowTrailingSpace) {
        ret = ret.TrimStart(null);
      }
      else {
        ret = ret.Trim();
      }
      
      return ret;
    }
    
#if false
    // this seems to have the same notion of "ASCII" as the version above,
    // except it replaces non-ASCII characters with "?", which would be fine if the text-entry field does the same,
    // but the text-entry field just strips them out (presumably because they're not in the font),
    // so going with the stripping-out version above.
    public static string sanitizeFilenameVersion2(string s) {
      string ret = Encoding.ASCII.GetString(Encoding.ASCII.GetBytes(s));
      if (ret != s) {
        WWLog.logWarn("simplified filename from \"" + s + "\" to \"" + ret + "\".");
      }
      
      ret = ret.Trim();
      
      return ret;
    }
#endif
  }
}


