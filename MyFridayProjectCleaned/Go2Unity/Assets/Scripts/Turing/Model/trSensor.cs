using UnityEngine;
using System.Collections.Generic;
using WW.SimpleJSON;
using PI;


// this class is responsible for normalizing the natural input from a given sensor into the range [0, 1].
// this data is the same for all programs.

namespace Turing {

  public enum trSensorType {
    // note: the code below is generated by the spreadsheet at:
    //       https://docs.google.com/a/makewonder.com/spreadsheets/d/1cy1842eDd83pRsmid_8TE-RVlIhWCCR6s9kRRddGYig/edit#gid=1257986866
    DISTANCE_FRONT_LEFT_FACING,  // simple value from distance sensor.
    DISTANCE_FRONT_RIGHT_FACING,  // simple value from distance sensor.
    DISTANCE_FRONT_DELTA,  // right-facing minus left-facing.
    DISTANCE_FRONT,  // average of front distance sensors.
    DISTANCE_REAR,  // simple value from distance sensor.
    HEAD_PAN,  // value of headpan
    HEAD_TILT,  // headtilt
    TRAVEL_LINEAR,  // sine of distance travelled w/ period <param>
    TRAVEL_ANGULAR,  // sine of angle travelled w/ period <param>
    ROLL,  // Y-component of acceleration. (normalize xyz) 
    PITCH,  // X-component of acceleration. (normalize xyz) 
    TIME_IN_STATE,  // 
    RANDOM_NOISE,  // canned values, continuous. (eg 1D perlin noise)

    //deprecated
    TRAVEL_LINEAR_10,  // sine of distance travelled mod <full max>
    TRAVEL_LINEAR_50,  // sine of distance travelled mod <full max>
    TRAVEL_LINEAR_100,  // sine of distance travelled mod <full max>
    TRAVEL_ANGULAR_90,  // sine of angle travelled mod <full max>
    TRAVEL_ANGULAR_180,  // sine of angle travelled mod <full max>
    TRAVEL_ANGULAR_360,  // sine of angle travelled mod <full max>
    TIME_IN_STATE_1,  // 1s
    TIME_IN_STATE_2,  // 2s
    TIME_IN_STATE_5,  // 5s
    TIME_IN_STATE_10,  // 10s
  }

  public class trSensor : trTypedBase<trSensorType> {
  
    private piBotBo myRobot;
  
    private float initialDistance      = 0f; // cm
    private float initialDegrees       = 0f; // degrees
    private float initialSeconds       = 0f; // seconds
    
    public float ParameterValue = 0f;
    
    private static Dictionary<trSensorType, wwRange> naturalRanges     = null;
    private static Dictionary<trSensorType, bool   > infoParameterized = null;
    
    public trSensor() {}
    public trSensor(trSensorType typeVal) : base(typeVal) {
      // todo oxe: trSensor & trActuator should not inherit from trBase because the UUID is meaningless.
      //           however, the functionality of trTypedBase is nice, so perhaps that should be an interface.
      UUID = this.GetType().Name + "_" + typeVal.ToString();
    }
    
    #region serialization
    protected override void IntoJson(JSONClass jsc) {
      if (Parameterized(Type)) {
        jsc[TOKENS.PARAMETER_VALUE].AsFloat = ParameterValue;
      }
      base.IntoJson(jsc);
    }
    
    protected override void OutOfJson(JSONClass jsc) {
      base.OutOfJson(jsc);
      if (Parameterized(Type)) {
        ParameterValue = jsc[TOKENS.PARAMETER_VALUE].AsFloat;
      }
      fixDeprecatedSensorTypes();
    }

    private void fixDeprecatedSensorTypes(){
      trSensorType validType = Type;
      float parameterValue = float.NaN;
      
      switch(Type){
        case trSensorType.TRAVEL_LINEAR_10:
          parameterValue = 10;
          validType = trSensorType.TRAVEL_LINEAR;
          break;
        case trSensorType.TRAVEL_LINEAR_50:
          parameterValue = 50;
          validType = trSensorType.TRAVEL_LINEAR;
          break;
        case trSensorType.TRAVEL_LINEAR_100:
          parameterValue = 100;
          validType = trSensorType.TRAVEL_LINEAR;
          break;
          
        case trSensorType.TRAVEL_ANGULAR_90:
          parameterValue = 90;
          validType = trSensorType.TRAVEL_ANGULAR;
          break;
        case trSensorType.TRAVEL_ANGULAR_180:
          parameterValue = 180;
          validType = trSensorType.TRAVEL_ANGULAR;
          break;
        case trSensorType.TRAVEL_ANGULAR_360:
          parameterValue = 360;
          validType = trSensorType.TRAVEL_ANGULAR;
          break;
          
        case trSensorType.TIME_IN_STATE_1:
          parameterValue = 1;
          validType = trSensorType.TIME_IN_STATE;
          break;
        case trSensorType.TIME_IN_STATE_2:
          parameterValue = 2;
          validType = trSensorType.TIME_IN_STATE;
          break;
        case trSensorType.TIME_IN_STATE_5:
          parameterValue = 5;
          validType = trSensorType.TIME_IN_STATE;
          break;
        case trSensorType.TIME_IN_STATE_10:
          parameterValue = 10;
          validType = trSensorType.TIME_IN_STATE;
          break;
      }
      
      if (!float.IsNaN(parameterValue)){
        WWLog.logInfo(string.Format("Promoting trigger type {0} to {1} with parameter {2}", Type, validType, parameterValue));
        Type = validType;
        ParameterValue = parameterValue;
      }
    }
    #endregion serialization
    
    
    public static bool ShowToUser(trSensorType t, piBotBase robot) {

      bool ret;
      switch (t) {
      default:
        ret = true;
        break;
      case trSensorType.TIME_IN_STATE_1:
      case trSensorType.TIME_IN_STATE_2:
      case trSensorType.TIME_IN_STATE_5:
      case trSensorType.TIME_IN_STATE_10:
      
      case trSensorType.TRAVEL_ANGULAR_90:
      case trSensorType.TRAVEL_ANGULAR_180:
      case trSensorType.TRAVEL_ANGULAR_360:
      
      case trSensorType.TRAVEL_LINEAR_10:
      case trSensorType.TRAVEL_LINEAR_50:
      case trSensorType.TRAVEL_LINEAR_100:
        
        ret = false;
        break;
      case trSensorType.DISTANCE_FRONT:
      case trSensorType.DISTANCE_FRONT_DELTA:
      case trSensorType.DISTANCE_FRONT_LEFT_FACING:
      case trSensorType.DISTANCE_FRONT_RIGHT_FACING:
      case trSensorType.DISTANCE_REAR:
      case trSensorType.HEAD_PAN:
      case trSensorType.HEAD_TILT:
      case trSensorType.TRAVEL_LINEAR:
      case trSensorType.TRAVEL_ANGULAR:
        ret = robot == null || robot.robotType != piRobotType.DOT;
        break;
      }
      return ret;
    }
    
    
    public static Dictionary<trSensorType, wwRange> NaturalRanges {
      get {
        if (naturalRanges == null) {
          naturalRanges = new Dictionary<trSensorType, wwRange>();
          
          // note: the code below is generated by the spreadsheet at:
          //       https://docs.google.com/a/makewonder.com/spreadsheets/d/1cy1842eDd83pRsmid_8TE-RVlIhWCCR6s9kRRddGYig/edit#gid=1257986866
          naturalRanges[trSensorType.DISTANCE_FRONT_LEFT_FACING] = new wwRange(0f, 50f);
          naturalRanges[trSensorType.DISTANCE_FRONT_RIGHT_FACING] = new wwRange(0f, 50f);
          naturalRanges[trSensorType.DISTANCE_FRONT_DELTA] = new wwRange(-1f, 1f);
          naturalRanges[trSensorType.DISTANCE_FRONT] = new wwRange(2.5f, 50f);
          naturalRanges[trSensorType.DISTANCE_REAR] = new wwRange(2.5f, 50f);
          
          naturalRanges[trSensorType.HEAD_PAN] = new wwRange(-120f, 120f);
          naturalRanges[trSensorType.HEAD_TILT] = new wwRange(-22.5f, 7.5f);
          
          naturalRanges[trSensorType.TRAVEL_LINEAR] = new wwRange(0f, 1f);  // parameterized
          naturalRanges[trSensorType.TRAVEL_LINEAR_10] = new wwRange(0f, 10f);
          naturalRanges[trSensorType.TRAVEL_LINEAR_50] = new wwRange(0f, 50f);
          naturalRanges[trSensorType.TRAVEL_LINEAR_100] = new wwRange(0f, 100f);
          naturalRanges[trSensorType.TRAVEL_ANGULAR] = new wwRange(0f, 1f);  // parameterized
          naturalRanges[trSensorType.TRAVEL_ANGULAR_90] = new wwRange(0f, 90f);
          naturalRanges[trSensorType.TRAVEL_ANGULAR_180] = new wwRange(0f, 180f);
          naturalRanges[trSensorType.TRAVEL_ANGULAR_360] = new wwRange(0f, 360f);
          
          naturalRanges[trSensorType.ROLL] = new wwRange(-180f, 180f);
          naturalRanges[trSensorType.PITCH] = new wwRange(-180f, 180f);
          
          
          
          
          naturalRanges[trSensorType.TIME_IN_STATE] = new wwRange(0f, 600f);  // parameterized
          naturalRanges[trSensorType.TIME_IN_STATE_1] = new wwRange(0f, 1f);
          naturalRanges[trSensorType.TIME_IN_STATE_2] = new wwRange(0f, 2f);
          naturalRanges[trSensorType.TIME_IN_STATE_5] = new wwRange(0f, 5f);
          naturalRanges[trSensorType.TIME_IN_STATE_10] = new wwRange(0f, 10f);
          naturalRanges[trSensorType.RANDOM_NOISE] = new wwRange(0f, 1f);
        }
        return naturalRanges;
      }
    }
    
    public static bool Parameterized(trSensorType t) {
      if (infoParameterized == null) {
        infoParameterized = new Dictionary<trSensorType, bool>();
        // note: the code below is generated by the spreadsheet at:
        //       https://docs.google.com/a/makewonder.com/spreadsheets/d/1cy1842eDd83pRsmid_8TE-RVlIhWCCR6s9kRRddGYig/edit#gid=1257986866
        infoParameterized.Add(trSensorType.DISTANCE_FRONT_LEFT_FACING, false);
        infoParameterized.Add(trSensorType.DISTANCE_FRONT_RIGHT_FACING, false);
        infoParameterized.Add(trSensorType.DISTANCE_FRONT_DELTA, false);
        infoParameterized.Add(trSensorType.DISTANCE_FRONT, false);
        infoParameterized.Add(trSensorType.DISTANCE_REAR, false);
        infoParameterized.Add(trSensorType.HEAD_PAN, false);
        infoParameterized.Add(trSensorType.HEAD_TILT, false);
        infoParameterized.Add(trSensorType.TRAVEL_LINEAR, true);
        infoParameterized.Add(trSensorType.TRAVEL_LINEAR_10, false);
        infoParameterized.Add(trSensorType.TRAVEL_LINEAR_50, false);
        infoParameterized.Add(trSensorType.TRAVEL_LINEAR_100, false);
        infoParameterized.Add(trSensorType.TRAVEL_ANGULAR, true);
        infoParameterized.Add(trSensorType.TRAVEL_ANGULAR_90, false);
        infoParameterized.Add(trSensorType.TRAVEL_ANGULAR_180, false);
        infoParameterized.Add(trSensorType.TRAVEL_ANGULAR_360, false);
        infoParameterized.Add(trSensorType.ROLL, false);
        infoParameterized.Add(trSensorType.PITCH, false);
        infoParameterized.Add(trSensorType.TIME_IN_STATE, true);
        infoParameterized.Add(trSensorType.TIME_IN_STATE_1, false);
        infoParameterized.Add(trSensorType.TIME_IN_STATE_2, false);
        infoParameterized.Add(trSensorType.TIME_IN_STATE_5, false);
        infoParameterized.Add(trSensorType.TIME_IN_STATE_10, false);
        infoParameterized.Add(trSensorType.RANDOM_NOISE, false);
                        
        // verify coverage  
        foreach (trSensorType enumCandidate in System.Enum.GetValues(typeof(trSensorType))) {
          if (!infoParameterized.ContainsKey(enumCandidate)) {
            WWLog.logError("sensor type has no infoParameterized info, using false: " + enumCandidate.ToString());
            infoParameterized.Add(enumCandidate, false);
          }
        }
      }
      
      return infoParameterized[t];
    }    
    public piBotBo Robot {
      set {
        bool needReset = (Robot != myRobot);
        myRobot = value;
        if (needReset) {
          reset();
        }
      }
      get {
        return myRobot;
      }
    }
    
    private static float AverageEncoderDistance(piBotAxled robot) {
      return (robot.WheelLeft.encoderDistance.Value + robot.WheelRight.encoderDistance.Value) / 2f;
    }
    
    public void reset() {
      if (myRobot != null) {
        initialDistance = AverageEncoderDistance(myRobot);
        initialDegrees  = myRobot.BodyPoseSensor.radians * Mathf.Rad2Deg;
      }
      initialSeconds  = Time.time;
    }
    
    public float LinearTravel {
      get {
        return AverageEncoderDistance(myRobot) - initialDistance;
      }
    }
    
    public float AngularTravel {
      get {
        return myRobot.BodyPoseSensor.radians * Mathf.Rad2Deg - initialDegrees;
      }
    }
    
    public float TimeInState {
      get {
        return Time.time - initialSeconds;
      }
    }
    
    public float ValueNormalized {
      get {
        float valueNatural = float.NaN;
        bool invert = false;
        
        switch (Type) {
          default:
            if (wwDoOncePerTypeVal<trSensorType>.doIt(Type)) {
              WWLog.logError("unhandled sensor: " + Type.ToString());
            }
            return 0;
          case trSensorType.DISTANCE_FRONT_LEFT_FACING:
            valueNatural = myRobot.DistanceSensorFrontLeft.WindowedDistance;
            break;
          case trSensorType.DISTANCE_FRONT_RIGHT_FACING:
            valueNatural = myRobot.DistanceSensorFrontRight.WindowedDistance;
            break;
          case trSensorType.DISTANCE_FRONT_DELTA:
            float sum = myRobot.DistanceSensorFrontRight.WindowedDistance + myRobot.DistanceSensorFrontLeft.WindowedDistance;
            if (piMathUtil.withinEpsilon(sum)) {
              valueNatural = 0;
            }
            else {
              float dif = myRobot.DistanceSensorFrontRight.distance - myRobot.DistanceSensorFrontLeft.distance;
              valueNatural = dif / sum;
            }
            break;
          case trSensorType.DISTANCE_FRONT:
            valueNatural = (myRobot.DistanceSensorFrontLeft.WindowedDistance + myRobot.DistanceSensorFrontRight.WindowedDistance) / 2f;
            break;
//          case trSensorType.DIRECTION_FRONT:
//            WWLog.logError("todo: implement sensor: " + Type.ToString());
//            break;
          case trSensorType.DISTANCE_REAR:
            valueNatural = myRobot.DistanceSensorTail.WindowedDistance;
            break;
          case trSensorType.HEAD_PAN:
            valueNatural = (myRobot.HeadPanSensor.angle.valTarget) * Mathf.Rad2Deg;
            invert = true;
            break;
          case trSensorType.HEAD_TILT:
            valueNatural = (myRobot.HeadTiltSensor.angle.valTarget) * Mathf.Rad2Deg;
            invert = true;
            break;
          case trSensorType.ROLL:
            valueNatural = myRobot.Accelerometer.WindowedRoll;
            break;
          case trSensorType.PITCH:
            valueNatural = myRobot.Accelerometer.WindowedPitch;
            break;
          case trSensorType.TRAVEL_LINEAR:
            valueNatural = parameterizedToPeriodic(LinearTravel, ParameterValue);
            break;
          case trSensorType.TRAVEL_LINEAR_10:
          case trSensorType.TRAVEL_LINEAR_50:
          case trSensorType.TRAVEL_LINEAR_100:
            valueNatural = unboundedToPeriodic(LinearTravel, NaturalRanges[Type].Span);
            break;
          case trSensorType.TRAVEL_ANGULAR:
            valueNatural = parameterizedToPeriodic(AngularTravel, ParameterValue);
            break;
          case trSensorType.TRAVEL_ANGULAR_90:
          case trSensorType.TRAVEL_ANGULAR_180:
          case trSensorType.TRAVEL_ANGULAR_360:
            valueNatural = unboundedToPeriodic(AngularTravel, NaturalRanges[Type].Span);
            break;
          case trSensorType.TIME_IN_STATE:
            valueNatural = parameterizedToPeriodic(TimeInState, ParameterValue);
            break;
          case trSensorType.TIME_IN_STATE_1:
          case trSensorType.TIME_IN_STATE_2:
          case trSensorType.TIME_IN_STATE_5:
          case trSensorType.TIME_IN_STATE_10:
            valueNatural = unboundedToPeriodic(TimeInState, NaturalRanges[Type].Span);
            break;
          case trSensorType.RANDOM_NOISE:
            valueNatural = wwRandom.getValue();
            break;
//          case trSensorType.AMBIENT_VOLUME:
//            valueNatural = myRobot.SoundSensor.amplitude; // todo: verify this works.
//            break;
//          case trSensorType.PREVIOUS_VOICE_DIRECTION:
//            WWLog.logError("todo: implement sensor: " + Type.ToString());
//            break;
        }
        
        float valueMin = NaturalRanges[Type].Min;
        float valueMax = NaturalRanges[Type].Max;
        
        
        
        // normalize:
        float valueNormalized;
        float naturalRange = valueMax - valueMin;
        if (piMathUtil.withinEpsilon(naturalRange, 0.00001f)) {
          valueNormalized = (valueMin + valueMax) / 2.0f;
        }
        else {
          valueNormalized = (valueNatural - valueMin) / naturalRange;
        }
        
        if (invert) {
          valueNormalized = 1.0f - valueNormalized;
        }
        
        // todo: is clamping here what we want ?
        valueNormalized = Mathf.Clamp01(valueNormalized);
        
        return valueNormalized;
      }
    }
    
    private float parameterizedToPeriodic(float value, float parameter) {
      float ret;
      if (piMathUtil.withinEpsilon(parameter)) {
        ret = 0.5f;
      }
      else {
        ret = unboundedToPeriodic(value, parameter) / parameter;
      }
      return ret;
    }
    
    private static float unboundedToPeriodic(float value, float period) {
      float ret = (Mathf.Sin(value / period * Mathf.PI * 2.0f) * 0.5f + 0.5f) * period;
      return ret;
    }
  }
}


